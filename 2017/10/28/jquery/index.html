<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Cary"><meta name="keywords" content="个人博客"><meta name="description" conauthortent="若尧的博客"><link rel="alternative" href="/atom.xml" title="若尧" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>jQuery源码浅析 - 若尧</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><div class="hide" id="particles-oli-wrapper"></div><header class="head"><h1 class="head-title u-fl"><a href="/">若尧</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">目录</a></li><li class="head-nav__item"><a class="head-nav__link" href="/about">关于</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2017-10-28T00:22:47.000Z">十月 28, 2017</time><h1 class="post__title"><a href="/2017/10/28/jquery/">jQuery源码浅析</a></h1><div class="post__main echo"><h3 id="1-jQuery闭包结构"><a href="#1-jQuery闭包结构" class="headerlink" title="1.jQuery闭包结构"></a>1.jQuery闭包结构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// jQuery 代码</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>jQuery 具体的实现，都被包含在了一个立即执行函数构造的闭包里面，为了不污染全局作用域，只在后面暴露 $ 和 jQuery 这 2 个变量给外界，尽量的避开变量冲突。</p>
<p>还有另一种写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// jQuery 代码</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure></p>
<p>不足之处在于早期的环境中（ie8）,undefined的值可以被变量覆盖。<br>而且第一种写法有一个针对压缩优化细节：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩策略</span></span><br><span class="line"><span class="comment">// w -&gt; windwow , u -&gt; undefined</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">w, u</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-jQuery无new构造"><a href="#2-jQuery无new构造" class="headerlink" title="2.jQuery无new构造"></a>2.jQuery无new构造</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无 new 构造</span></span><br><span class="line">$(<span class="string">'#test'</span>).text(<span class="string">'Test'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当然也可以使用 new,两种写法相同</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> $(<span class="string">'#test'</span>);</span><br><span class="line">test.text(<span class="string">'Test'</span>);</span><br></pre></td></tr></table></figure>
<p>jQuery内部实现的方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// The jQuery object is actually just the init constructor 'enhanced'</span></span><br><span class="line">        <span class="comment">// 看这里，实例化方法 jQuery() 实际上是调用了其拓展的原型方法 jQuery.fn.init</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context, rootjQuery);</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// jQuery.prototype 即是 jQuery 的原型，挂载在上面的方法，即可让所有生成的 jQuery 对象使用</span></span><br><span class="line">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">        <span class="comment">// 实例化化方法，这个方法可以称作 jQuery 对象构造器</span></span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params">selector, context, rootjQuery</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这一句很关键，也很绕</span></span><br><span class="line">    <span class="comment">// jQuery 没有使用 new 运算符将 jQuery 实例化，而是直接调用其函数</span></span><br><span class="line">    <span class="comment">// 要实现这样,那么 jQuery 就要看成一个类，且返回一个正确的实例</span></span><br><span class="line">    <span class="comment">// 且实例还要能正确访问 jQuery 类原型上的属性与方法</span></span><br><span class="line">    <span class="comment">// jQuery 的方式是通过原型传递解决问题，把 jQuery 的原型传递给jQuery.prototype.init.prototype</span></span><br><span class="line">    <span class="comment">// 所以通过这个方法生成的实例 this 所指向的仍然是 jQuery.fn，所以能正确访问 jQuery 类原型上的属性与方法</span></span><br><span class="line">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"> </span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p>
<p>实例化方法存在的关系链：<br>(1)jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype ;<br>(2)new jQuery.fn.init() 相当于 new jQuery() ;<br>(3)jQuery() 返回的是 new jQuery.fn.init()，而 var obj = new jQuery()，所以这 2 者是相当的，所以我们可以无 new 实例化 jQuery 对象。</p>
<h3 id="3-jQuery方法的重载"><a href="#3-jQuery方法的重载" class="headerlink" title="3.jQuery方法的重载"></a>3.jQuery方法的重载</h3><p>当我们实例化一个jquery对象时，他的内部实现有着9种不同的方法重载场景。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个字符串，其中包含了用于匹配元素集合的 CSS 选择器</span></span><br><span class="line">jQuery([selector,[context]])</span><br><span class="line"><span class="comment">// 传入单个 DOM</span></span><br><span class="line">jQuery(element)</span><br><span class="line"><span class="comment">// 传入 DOM 数组</span></span><br><span class="line">jQuery(elementArray)</span><br><span class="line"><span class="comment">// 传入 JS 对象</span></span><br><span class="line">jQuery(object)</span><br><span class="line"><span class="comment">// 传入 jQuery 对象</span></span><br><span class="line">jQuery(jQuery object)</span><br><span class="line"><span class="comment">// 传入原始 HTML 的字符串来创建 DOM 元素</span></span><br><span class="line">jQuery(html,[ownerDocument])</span><br><span class="line">jQuery(html,[attributes])</span><br><span class="line"><span class="comment">// 传入空参数</span></span><br><span class="line">jQuery()</span><br><span class="line"><span class="comment">// 绑定一个在 DOM 文档载入完成后执行的函数</span></span><br><span class="line">jQuery(callback)</span><br></pre></td></tr></table></figure></p>
<h3 id="4-jQuery-fn-extend-与-jQuery-extend"><a href="#4-jQuery-fn-extend-与-jQuery-extend" class="headerlink" title="4.jQuery.fn.extend 与 jQuery.extend"></a>4.jQuery.fn.extend 与 jQuery.extend</h3><p>不同之处在于：</p>
<p><1><br>jQuery.extend(object) 为扩展 jQuery 类本身，为类添加新的静态方法；</1></p>
<p>jQuery.fn.extend(object) 给 jQuery 对象添加实例方法，也就是通过这个 extend 添加的新方法，实例化的 jQuery 对象都能使用，因为它是挂载在 jQuery.fn 上的方法（上文有提到，jQuery.fn = jQuery.prototype ）。 </p>
<p><2><br>使用 jQuery.extend() 拓展的静态方法，我们可以直接使用 $.xxx 进行调用（xxx是拓展的方法名），</2></p>
<p>而使用 jQuery.fn.extend() 拓展的实例方法，需要使用 $().xxx 调用。</p>
<p><3><br>在 jQuery.extend() 中，this 的指向是 jQuery 对象(或者说是 jQuery 类)，所以这里扩展在 jQuery 上；</3></p>
<p>在 jQuery.fn.extend() 中，this 的指向是 fn 对象，前面有提到 jQuery.fn = jQuery.prototype ，也就是这里增加的是原型方法，也就是对象方法。</p>
<h3 id="5-jQuery-的链式调用及回溯"><a href="#5-jQuery-的链式调用及回溯" class="headerlink" title="5.jQuery 的链式调用及回溯"></a>5.jQuery 的链式调用及回溯</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 end() 方法终止在当前链的最新过滤操作，返回上一个对象集合</span></span><br><span class="line">$(<span class="string">'div'</span>).eq(<span class="number">0</span>).show().end().eq(<span class="number">1</span>).hide();</span><br></pre></td></tr></table></figure>
<p>其内部实现其实是依靠添加了 prevObject 这个属性,源码实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    <span class="comment">// 将一个 DOM 元素集合加入到 jQuery 栈</span></span><br><span class="line">    <span class="comment">// 此方法在 jQuery 的 DOM 操作中被频繁的使用, 如在 parent(), find(), filter() 中</span></span><br><span class="line">    <span class="comment">// pushStack() 方法通过改变一个 jQuery 对象的 prevObject 属性来跟踪链式调用中前一个方法返回的 DOM 结果集合</span></span><br><span class="line">    <span class="comment">// 当我们在链式调用 end() 方法后, 内部就返回当前 jQuery 对象的 prevObject 属性</span></span><br><span class="line">    pushStack: <span class="function"><span class="keyword">function</span>(<span class="params">elems</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 构建一个新的jQuery对象，无参的 this.constructor()，只是返回引用this</span></span><br><span class="line">        <span class="comment">// jQuery.merge 把 elems 节点合并到新的 jQuery 对象</span></span><br><span class="line">        <span class="comment">// this.constructor 就是 jQuery 的构造函数 jQuery.fn.init，所以 this.constructor() 返回一个 jQuery 对象</span></span><br><span class="line">        <span class="comment">// 由于 jQuery.merge 函数返回的对象是第二个函数附加到第一个上面，所以 ret 也是一个 jQuery 对象，这里可以解释为什么 pushStack 出入的 DOM 对象也可以用 CSS 方法进行操作</span></span><br><span class="line">        <span class="keyword">var</span> ret = jQuery.merge(<span class="keyword">this</span>.constructor(), elems);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 给返回的新 jQuery 对象添加属性 prevObject</span></span><br><span class="line">        <span class="comment">// 所以也就是为什么通过 prevObject 能取到上一个合集的引用了</span></span><br><span class="line">        ret.prevObject = <span class="keyword">this</span>;</span><br><span class="line">        ret.context = <span class="keyword">this</span>.context;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Return the newly-formed element set</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 回溯链式调用的上一个对象</span></span><br><span class="line">    end: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 回溯的关键是返回 prevObject 属性</span></span><br><span class="line">        <span class="comment">// 而 prevObject 属性保存了上一步操作的 jQuery 对象集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.prevObject || <span class="keyword">this</span>.constructor(<span class="literal">null</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 取当前 jQuery 对象的第 i 个</span></span><br><span class="line">    eq: <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// jQuery 对象集合的长度</span></span><br><span class="line">        <span class="keyword">var</span> len = <span class="keyword">this</span>.length,</span><br><span class="line">            j = +i + (i &lt; <span class="number">0</span> ? len : <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 利用 pushStack 返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pushStack(j &gt;= <span class="number">0</span> &amp;&amp; j &lt; len ? [<span class="keyword">this</span>[j]] : []);</span><br><span class="line">    &#125;, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总的来说，</p>
<p>1）end() 方法返回 prevObject 属性，这个属性记录了上一步操作的 jQuery 对象合集；</p>
<p>2）而 prevObject 属性由 pushStack() 方法生成，该方法将一个 DOM 元素集合加入到 jQuery 内部管理的一个栈中，通过改变 jQuery 对象的 prevObject 属性来跟踪链式调用中前一个方法返回的 DOM 结果集合</p>
<p>3）当我们在链式调用 end() 方法后，内部就返回当前 jQuery 对象的 prevObject 属性，完成回溯。</p>
<h3 id="6-jQuery-变量冲突处理"><a href="#6-jQuery-变量冲突处理" class="headerlink" title="6.jQuery 变量冲突处理"></a>6.jQuery 变量冲突处理</h3><p>当需要处理冲突的时候，调用静态方法 noConflict()，让出变量的控制权，源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        <span class="comment">// Map over jQuery in case of overwrite</span></span><br><span class="line">        <span class="comment">// 设置别名，通过两个私有变量映射了 window 环境下的 jQuery 和 $ 两个对象，以防止变量被强行覆盖</span></span><br><span class="line">        _jQuery = <span class="built_in">window</span>.jQuery,</span><br><span class="line">        _$ = <span class="built_in">window</span>.$;</span><br><span class="line"> </span><br><span class="line">    jQuery.extend(&#123;</span><br><span class="line">        <span class="comment">// noConflict() 方法让出变量 $ 的 jQuery 控制权，这样其他脚本就可以使用它了</span></span><br><span class="line">        <span class="comment">// 通过全名替代简写的方式来使用 jQuery</span></span><br><span class="line">        <span class="comment">// deep -- 布尔值，指示是否允许彻底将 jQuery 变量还原(移交 $ 引用的同时是否移交 jQuery 对象本身)</span></span><br><span class="line">        noConflict: <span class="function"><span class="keyword">function</span>(<span class="params">deep</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 判断全局 $ 变量是否等于 jQuery 变量</span></span><br><span class="line">            <span class="comment">// 如果等于，则重新还原全局变量 $ 为 jQuery 运行之前的变量（存储在内部变量 _$ 中）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">window</span>.$ === jQuery) &#123;</span><br><span class="line">                <span class="comment">// 此时 jQuery 别名 $ 失效</span></span><br><span class="line">                <span class="built_in">window</span>.$ = _$;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当开启深度冲突处理并且全局变量 jQuery 等于内部 jQuery，则把全局 jQuery 还原成之前的状况</span></span><br><span class="line">            <span class="keyword">if</span> (deep &amp;&amp; <span class="built_in">window</span>.jQuery === jQuery) &#123;</span><br><span class="line">                <span class="comment">// 如果 deep 为 true，此时 jQuery 失效</span></span><br><span class="line">                <span class="built_in">window</span>.jQuery = _jQuery;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 这里返回的是 jQuery 库内部的 jQuery 构造函数（new jQuery.fn.init()）</span></span><br><span class="line">            <span class="comment">// 像使用 $ 一样尽情使用它吧</span></span><br><span class="line">            <span class="keyword">return</span> jQuery;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/javascript/">javascript</a></li><li class="post__tag__item"><a class="post__tag__link" href="/tags/jQuery/">jQuery</a></li></ul></footer></article><link rel="stylesheet" href="/css/menu.css"><script src="/js/jquery.autoMenu.js"></script><div class="autoMenu" id="autoMenu" data-autoMenu></div><section class="reward"> <a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechatImage.jpg" title="微信"><img src="/img/alipayImage.jpg" title="支付宝"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2016-2018 Cary</div></footer><!--include ../plugins/google.pug--><script src="/js/particles.min.js"></script><script src="/js/particles.other.js"></script><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>